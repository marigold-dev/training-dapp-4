#import "./pokeGame.jsligo" "PokeGame"
export type main_fn = module_contract<parameter_of PokeGame, PokeGame.storage>;

const _ = Test.reset_state(2 as nat, list([]) as list<tez>);

const faucet = Test.nth_bootstrap_account(0);

const sender1: address = Test.nth_bootstrap_account(1);

const _ = Test.log("Sender 1 has balance : ");

const _ = Test.log(Test.get_balance(sender1));

const _ = Test.set_baker(faucet);

const _ = Test.set_source(faucet);

const initial_storage =
{
pokeTraces : Map.empty as map<address, PokeGame.pokeMessage> ,
feedback : "kiss" ,
ticketOwnership : Map.empty as map<address,ticket<string>>};

const initial_tez = 0 as tez;

export const _testPoke = (
  taddr: typed_address<parameter_of PokeGame, PokeGame.storage>,
  s: address,
  ticketCount: nat,
  expectedResult: bool
): unit => {
  const contr = Test.to_contract(taddr);
  const contrAddress = Tezos.address(contr);
  Test.log("contract deployed with values : ");
  Test.log(contr);
  Test.set_source(s);
  const statusInit =
    Test.transfer_to_contract(contr, Init([sender1, ticketCount]), 0 as tez);
  Test.log(statusInit);
  Test.log("*** Check initial ticket is here ***");
  Test.log(Test.get_storage(taddr));
  const status: test_exec_result =
    Test.transfer_to_contract(contr, Poke(), 0 as tez);
  Test.log(status);
  const store: PokeGame.storage = Test.get_storage(taddr);
  Test.log(store);
  return match(
    status,
    {
      Fail: (tee: test_exec_error) =>
        match(
          tee,
          {
            Other: (msg: string) =>
              assert_with_error(expectedResult == false, msg),
            Balance_too_low: (_record: test_exec_error_balance_too_low) =>
              assert_with_error(
                expectedResult == false,
                "ERROR Balance_too_low"
              ),
            Rejected: (s: [michelson_program, address]) =>
              assert_with_error(expectedResult == false, Test.to_string(s[0]))
          }
        ),
      Success: (_n: nat) =>
        match(
          Map.find_opt(
            s,
            (Test.get_storage(taddr) as PokeGame.storage).pokeTraces
          ),
          {
            Some: (pokeMessage: PokeGame.pokeMessage) => {
              assert_with_error(
                pokeMessage.feedback == "",
                "feedback " + pokeMessage.feedback +
                  " is not equal to expected " + "(empty)"
              );
              assert_with_error(
                pokeMessage.receiver == contrAddress,
                "receiver is not equal"
              )
            },
            None: () =>
              assert_with_error(expectedResult == false, "don't find traces")
          }
        )
    }
  )
};

const _ = Test.log("*** Run test to pass ***");

const testSender1Poke =
  (
    (): unit => {
      const [taddr, _, _] =
        Test.originate_module(
          contract_of(PokeGame),
          initial_storage,
          initial_tez
        );
      _testPoke(taddr, sender1, 1 as nat, true)
    }
  )();

const _ = Test.log("*** Run test to fail ***");

const testSender1PokeWithNoTicketsToFail =
  (
    (): unit => {
      const [taddr, _, _] =
        Test.originate_module(
          contract_of(PokeGame),
          initial_storage,
          initial_tez
        );
      _testPoke(taddr, sender1, 0 as nat, false)
    }
  )(); 
  
