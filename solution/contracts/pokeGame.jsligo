export type pokeMessage = { receiver: address, feedback: string };

export type realStorage = {
  pokeTraces: map<address, pokeMessage>,
  feedback: string,
  ticketOwnership: map<address, ticket<string>>, //ticket of claims

};

export type storage = { storage: realStorage; dynamic_entrypoints };

type return_ = [list<operation>, storage];

@dyn_entry
const pokeDefaultFunction = (_: unit, store: storage): return_ => {
  const { storage, dynamic_entrypoints } = store;
  const { pokeTraces, feedback, ticketOwnership } = storage;
  const [t, tom]: [option<ticket<string>>, map<address, ticket<string>>] =
    Map.get_and_update(
      Tezos.get_source(),
      None() as option<ticket<string>>,
      ticketOwnership
    );
  return match(t) {
    when (None()):
      failwith("User does not have tickets => not allowed")
    when (Some(_t)):
      [
        list([]) as list<operation>,
        {
          dynamic_entrypoints,
          storage: {
            feedback,
            pokeTraces: Map.add(
              Tezos.get_source(),
              { receiver: Tezos.get_self_address(), feedback: "" },
              pokeTraces
            ),
            ticketOwnership: tom
          }
        }
      ]
  }
};

/*
  @dyn_entry
  const pokeAndGetFeedback = (oracleAddress: address, store: storage): return_ => {
    const { pokeTraces, feedback, ticketOwnership } = store.storage;
    ignore(feedback);
    const [t, tom]: [option<ticket<string>>, map<address, ticket<string>>] =
      Map.get_and_update(
        Tezos.get_source(),
        None() as option<ticket<string>>,
        ticketOwnership
      );
    let feedbackOpt: option<string> =
      Tezos.call_view("feedback", unit, oracleAddress);
    return match(t) {
      when (None()):
        failwith("User does not have tickets => not allowed")
      when (Some(_t)):
        match(feedbackOpt) {
          when (Some(feedback)):
            do {
              let feedbackMessage = {
                receiver: oracleAddress,
                feedback: feedback
              };
              return [
                list([]) as list<operation>,
                {
                  ...store,
                  storage: {
                    feedback,
                    pokeTraces: Map.add(
                      Tezos.get_source(),
                      feedbackMessage,
                      pokeTraces
                    ),
                    ticketOwnership: tom
                  }
                }
              ]
            }
          when (None()):
            failwith("Cannot find view feedback on given oracle address")
        }
    }
  };

  */

@entry
const init = ([a, ticketCount]: [address, nat], store: storage): return_ => {
  const { storage, dynamic_entrypoints } = store;
  const { pokeTraces, feedback, ticketOwnership } = storage;
  if (ticketCount == (0 as nat)) {
    return [
      list([]) as list<operation>,
      {
        dynamic_entrypoints,
        storage: { pokeTraces, feedback, ticketOwnership }
      }
    ]
  } else {
    const t: ticket<string> =
      Option.unopt(Tezos.create_ticket("can_poke", ticketCount));
    return [
      list([]) as list<operation>,
      {
        dynamic_entrypoints,
        storage: {
          pokeTraces,
          feedback,
          ticketOwnership: Map.add(a, t, ticketOwnership)
        }
      }
    ]
  }
};

@view
const getView = (viewName: string, store: storage): bytes => {
  if (viewName == "feedback") {
    return Bytes.pack(store.storage.feedback);
  } else return failwith("View " + viewName + " not found on this contract");
};

@entry
const setPoke = (pokeEntrypoint: entrypoint<unit, storage>, s: storage): [
  list<operation>,
  storage
] => {
  const { storage, dynamic_entrypoints } = s;
  const { pokeTraces, feedback, ticketOwnership } = storage;
  let de =
    Dynamic_entrypoints.set(
      pokeDefaultFunction,
      Some(pokeEntrypoint),
      dynamic_entrypoints
    );
  return [
    list([]),
    {
      storage: { pokeTraces, feedback, ticketOwnership },
      dynamic_entrypoints: de
    }
  ]
}

@entry
const poke = (_: unit, s: storage): return_ => {
  const { storage, dynamic_entrypoints } = s;
  const { pokeTraces, feedback, ticketOwnership } = storage;
  match(Dynamic_entrypoints.get(pokeDefaultFunction, dynamic_entrypoints)) {
    when (Some(f)):
      do {
        const [op, newStorage] =
          f(
            _,
            {
              storage: { pokeTraces, feedback, ticketOwnership },
              dynamic_entrypoints
            }
          );
        return [op, newStorage]
      }
    when (None()):
      failwith(-1)
  }
}
